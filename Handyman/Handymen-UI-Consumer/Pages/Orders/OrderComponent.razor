@page "/order-component"
@using HandymanUILibrary.Models
@using Handymen_UI_Consumer.Helpers
@using Handymen_UI_Consumer.Pages.Orders.Tasks
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web

@inject NavigationManager NavManager
@inject ILogger<OrderComponent> Logger
@inject PersistentComponentState ApplicationState
@inject IOrderHelper _orderHelper
@implements IDisposable

<!--Order Component MarkUp-->
<div class="row">
<dl class="col align-content-center">
        
        <div class="card mb-3 ">
          <div class="row g-0">
            <div class="col-md-4">
                <img src="/Images/@(order.service.img)" class="img-fluid rounded-start" alt="...">
            </div>
            <div class="col-md-8">
              <div class="card-body">
                    <h5 class="card-title" id="orderName">@order.service.name</h5>
                    <p class="card-text" id="orderDescription"> @order.service.category.description</p>
                    <p class="card-text"><small class="text-muted">@order.datecreated.ToString("MMMM dd, yyyy")</small></p>
              </div>
            </div>
          </div>
        </div>
            @*
                ### Button display logic in a re-usable component###
                If the order is confirmed by the consumer and by the service provider accepted --display tracking button
                If the order is not confirmed by the consumer (and ofcourse by default cannot be accepted by a service provider) --display confirm button
            *@

            @if(order.status > 3)
            {
                <button  class="btn btn-outline-success" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRight" aria-controls="offcanvasRight">Track Order</button>
            
            }
            
            @if (order.status < 1)
            {
                <button @onclick="ConfirmOrder" type="button" class="btn btn-primary m-3" data-bs-toggle="modal" data-bs-target="#staticBackdropConfirmorder"> Confirm </button>
            }
       
   
</dl>
    @if (order.status < 1)
    {
       
        <DynamicComponent Type="@typeof(OrderTasksComponent)" @ref="@orderTasksComponent" Parameters="@taskParam" />
                    
        <div>
            <button @onclick="AddToTasks" class="btn btn-primary m-3">Add</button>
        </div>
            
        
    }
    @if (order.status > 0 || taskList.Count() > 0)
    {
        <!--List of task-items in the confirmed order-->
        <div class="list-group list-group-flush align-content-lg-center">


           @foreach (var item in taskList)
           {
                
                <OrderTasksComponent isNew="false" 
                             description="@item.tas_description"
                             dateStarted="@item.tas_date_started" 
                             duration="@item.tas_duration" 
                             serviceId="@item.tas_service_id" 
                             status="@item.tas_status" 
                             title="@item.tas_title">
                </OrderTasksComponent>
           }
        </div>
        <!--End List-->
    }
</div>
@if (ErrorMsg != null)
{
    <p>
        @ErrorMsg
    </p>
}

@code {

    OrderModel order = new()!;
    TaskModel newTask = new()!;

    string? ErrorMsg;

    DynamicComponent? orderTasksComponent;
    IDictionary<string, object>? taskParam;
    List<TaskModel>? taskList = new()!;

    [Parameter]
    public OrderModel? OrderComponentModel
    {
        get
        {
            return order; 
        }

        set
        {
            order = value;

        }
    }

    protected override async Task OnInitializedAsync()
    {
        //NavManager.LocationChanged += HandleLocationChanged;
        if(order.status == 0)
        {
            taskParam = new Dictionary<string, object>()
                {
                    ["title"] = "123",
                    ["description"] = "321",
                    ["duration"] = 111,
                    ["status"] = 111,
                    ["isNew"] = true,
                    ["serviceId"] = order.service.id,
                    ["dateStarted"] = DateTime.Now,
                    ["Id"] = 0,
                    ["dateFinished"] = DateTime.Now

                };
        }else
        {
            taskList = order?.Tasks?.ToList();
        }
    }

    void AddToTasks()
    {
        var tasksComponent = (OrderTasksComponent)orderTasksComponent?.Instance;//cast the dynamic component...finders cross x
        
        //Tasks population
        newTask = new()!;
        newTask.tas_title = tasksComponent?.NewTask.tas_title;
        newTask.tas_status = tasksComponent.NewTask.tas_status;
        newTask.tas_duration = tasksComponent.duration;
        newTask.tas_description = tasksComponent?.NewTask.tas_description;
        newTask.tas_date_finished = tasksComponent.NewTask.tas_date_finished;
        newTask.tas_date_started = DateTime.UtcNow;
        newTask.tas_service_id = order.service.id;

        taskList.Add(newTask);

    }
    //Redirection in razor component
    void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        Logger.LogInformation("URL of new location: {Location}", e.Location);
    }

    //Disposing the component
    public void Dispose()
    {
        NavManager.LocationChanged -= HandleLocationChanged;

    }

    //Initiate the order track --soon to be in load orders
    //void TrackOrder()
    //{

    //    //order.IsTracking = true;
    //    // NavManager.NavigateTo($"/orderdetails?id={@order.Id}", true);
    //    NavManager.NavigateTo("/orders/ordertracker",true);
    //}

    //Cancelling --soon to be in Helper orders
    async Task CancelOrder()
    {

        Dispose();

    }

    //Completing the order on certain --loaders class 
    async Task FinishOrder()
    {

    }

    async Task UpateOrder()
    {

    }

    //Confirming the order placement--soon to be in ordershelper by all means
    async Task ConfirmOrder()
    {
        try
        {
            order.Tasks = taskList;
            order.datecreated = DateTime.Now;
            order.duedate = DateTime.Now;
            order.status = 1;
            await _orderHelper.CreateOrder(order);
        }
        catch (Exception ex)
        {
            ErrorMsg = ex.Message;
        }
    
    }

    [Authorize]
    public async Task DeleteOrder(OrderModel order)
    {
        try
        {

            await _orderHelper.DeleteOrder(order);
            NavManager.ToAbsoluteUri("/index");
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            ErrorMsg = ex.Message;

        }
    }
}
