@page "/orderComponent"
@using HandymanUILibrary.API
@using HandymanUILibrary.API.Consumer
@using Handymen_UI_Consumer.Areas.Identity.Data
@using Handymen_UI_Consumer.Helpers
@using Handymen_UI_Consumer.Models
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Caching.Memory
@using System.Security.Claims

@inject NavigationManager NavManager
@inject ILogger<OrderComponent> Logger
@inject PersistentComponentState ApplicationState
@inject IOrderHelper _orderHelper
@inject IMemoryCache _cache
@inject AuthenticationStateProvider _authenticationStateProvider
@inject IOrderEndPoint _orderEndPoint



<!--Order Component MarkUp-->
<dl class="row justify-content-center">
        <div class="card mb-3 " style="max-width: 540px;">
          <div class="row g-0">
            <div class="col-md-4">
                <img src="/Images/@(order.ServiceProperty.ImageUrl)" class="img-fluid rounded-start" alt="...">
            </div>
            <div class="col-md-8">
              <div class="card-body">
                    <h5 class="card-title" id="orderName">@order.ServiceProperty.Name</h5>
                    <p class="card-text" id="orderDescription"> @order.ServiceProperty.Description</p>
                    <p class="card-text"><small class="text-muted"> @order.DateCreated.ToString("MMMM dd, yyyy")</small></p>
              </div>
            </div>
          </div>

            @if(((order.IsAccepted==0) && (order.IsConfirmed)) || order.IsTracking)
            {
                <button @onclick="TrackOrder" class="btn btn-outline-success" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRight" aria-controls="offcanvasRight">View</button>
            }

            @if (!order.IsConfirmed && (order.IsAccepted==0))
            {

            <button @onclick="ConfirmOrder" type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#staticBackdropConfirmorder"> Confirm </button>
            }
           
            
        </div>
   
</dl>
    <!--End Component MarkUp-->



@code {
    private List<Service>? serviceDisplayList;
    public Order? order;
    private HubConnection? orderHubConnection;
    private HubConnection? requestHubConnection;
    private PersistingComponentStateSubscription persistingSubscription;
    string? ErrorMsg;
    string? IsAvailableMsg;
    bool IsProviderAvailable;
    bool OpenConnection;
    string? user;
    List<Order> userOrders;


    [Parameter]
    public Order? OrderComponentModel
    {
        get
        {
            return order; 
        }

        set
        {
            order = value;
        }
    }

    protected override async Task OnInitializedAsync()
    {

        try
        {

            //orderHubConnection = new HubConnectionBuilder()
            //.WithUrl("https://localhost:7168/orderhub")
            //.WithAutomaticReconnect()
            //.Build();


            //requestHubConnection = new HubConnectionBuilder()
            //.WithUrl("https://localhost:7168/requesthub")
            //.WithAutomaticReconnect()
            //.Build();

            ////Trying to connect
            //orderHubConnection.Reconnecting += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //    {
            //        var newMessage = "Trying to reconnect...";

            //    });

            //    return Task.CompletedTask;
            //};

            //requestHubConnection.Reconnecting += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //    {
            //        var newMessage = "Trying to reconnect...";

            //    });

            //    return Task.CompletedTask;
            //};

            ////Connected to server
            //orderHubConnection.Reconnected += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //{
            //    var newMessage = "Connected to the server";
            //    IsAvailableMsg = newMessage;
            //});

            //    return Task.CompletedTask;
            //};

            //requestHubConnection.Reconnected += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //{
            //    var newMessage = "Connected to the server";
            //    IsAvailableMsg = newMessage;
            //});

            //    return Task.CompletedTask;
            //};

            ////Closing connections
            //orderHubConnection.Closed += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //    {
            //        var newMessage = "Connection Closed";
            //        IsAvailableMsg = newMessage;
            //        IsProviderAvailable = false;
            //    });

            //    return Task.CompletedTask;
            //};

            //orderHubConnection.Closed += (sender) =>
            //{
            //    this.InvokeAsync(() =>
            //    {
            //        var newMessage = "Connection Closed";
            //        IsAvailableMsg = newMessage;
            //        IsProviderAvailable = false;
            //    });

            //    return Task.CompletedTask;
            //};

            ////Listening Client Side for available provider  
            //orderHubConnection.On<string>("ReceiveOrder", (status) =>
            //{
            //    order.Status = status;
            //    InvokeAsync(StateHasChanged);

            //});



            //await orderHubConnection.StartAsync();
            //await requestHubConnection.StartAsync();



            ////Caching the order model
            //if (!_cache.TryGetValue("ordercomp", out Order cacheValue))
            //{
            //    cacheValue = order;

            //    var cacheEntryOptions = new MemoryCacheEntryOptions()
            //        .SetSlidingExpiration(TimeSpan.FromSeconds(40));

            //    _cache.Set<Order>("ordercomp", cacheValue, cacheEntryOptions);
            //}

            //order = cacheValue;

            //NavManager.LocationChanged += HandleLocationChanged;
        }catch(Exception ex)
        {
            ErrorMsg = ex.Message;
        }

        //***Component persisting state setup****//
        persistingSubscription =
            ApplicationState.RegisterOnPersisting(PersistOrder);

        if (!ApplicationState.TryTakeFromJson<Order>(
            "fetchdata", out var restored))
        {
            //*The following code get the order from the IOrderEndPoint*//
            //order =
            await _orderHelper.LoadUserOrders();

        }
        else
        {
            order = restored!;
        }


        NavManager.LocationChanged += HandleLocationChanged;
    }


    //Send the Order to signalr request
    //User must be from Identity
    public async Task Send()
    {
        if(orderHubConnection is not null)
        {
            try
            {
                await orderHubConnection.SendAsync("SendOrder", user, order);
            }catch(Exception ex)
            {
                ErrorMsg = ex.Message;
            }
        }
    }

    //Redirection in razor component
    private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        Logger.LogInformation("URL of new location: {Location}", e.Location);
    }

    //Disposing the component
    public async ValueTask DisposeAsync()
    {
        if (orderHubConnection is not null)
        {
            //Dispose the cache
            //_cache.Remove("ordercomp");
            _cache.Dispose();
            try
            {

                NavManager.LocationChanged -= HandleLocationChanged;
               
                ErrorMsg = null;

            }catch(Exception ex)
            {
                ErrorMsg = ex.Message;
            }
            
        }

    }

    //Initiate the order track --soon to be in load orders
    private void TrackOrder()
    {

        //if (!_cache.TryGetValue("ordercomp", out Order cacheValue))
        //{
        //    cacheValue = order;

        //    var cacheEntryOptions = new MemoryCacheEntryOptions()
        //        .SetSlidingExpiration(TimeSpan.FromSeconds(40));

        //    _cache.Set<Order>("ordercomp", cacheValue, cacheEntryOptions);
        //}

        //order = cacheValue;
        order.IsTracking = true;
        NavManager.NavigateTo($"/orderdetails?id={@order.Id}", true);

        //NavManager.NavigateTo(NavManager.GetUriWithQueryParameters("orderdetails",
        //            new Dictionary<string, object>
        //                {
        //                    ["id"] = order.Id

        //            }));
    }

    //Cancelling --soon to be in load orders
    private async Task CancelOrder()
    {

        order.IsTracking = false;
        await DisposeAsync();
        persistingSubscription.Dispose();

    }

    //Completing the order on certain --loaders class 
    private async Task FinishOrder()
    {

    }

    //Persisting the order 
    private Task PersistOrder()
    {
        ApplicationState.PersistAsJson("fetorder", order);

        return Task.CompletedTask;
    }

    //Confirming the order placement--soon to be in ordershelper by all means
    public async Task ConfirmOrder()
    {
        HandymanUILibrary.Models.OrderModel libOrder = new();
    
        try
        {
            var user = (await _authenticationStateProvider.GetAuthenticationStateAsync()).User;
            var UserId = user.FindFirst(u => u.Type.Contains("nameidentifier"))?.Value;
            //Populate the order before posting it to db
            libOrder.ConsumerID = UserId.ToString();
            libOrder.IsAccepted = 0;//not accepted as yet, this is a new order
            libOrder.DateCreated =  DateTime.Now;
            //Service population

            //libOrder.Service.Name = order.ServiceProperty.Name;
            //libOrder.Service.Description = order.ServiceProperty.Description;
            //libOrder.Service.CategoryId = order.ServiceProperty.CategoryId;
            libOrder.ServiceId = order.ServiceProperty.Id;
            order.IsConfirmed = true;
            await _orderEndPoint.PostOrder(libOrder);
            NavManager.NavigateTo("index", true);
        }
        catch (Exception ex)
        {
            ErrorMsg = ex.Message;
        }
        
       

    }

}
