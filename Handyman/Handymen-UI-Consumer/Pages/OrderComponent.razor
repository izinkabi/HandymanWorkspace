@page "/orderComponent"
@using HandymanUILibrary.API
@using HandymanUILibrary.API.Consumer
@using Handymen_UI_Consumer.Helpers
@using Handymen_UI_Consumer.Models
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Caching.Memory

@inject NavigationManager NavManager
@inject ILogger<OrderComponent> Logger
@inject PersistentComponentState ApplicationState
@inject IOrderEndPoint _orderEndpointService
@inject IMemoryCache _cache

@implements IAsyncDisposable

<!--Order Component MarkUp-->
<dl class="row justify-content-center">
        <div class="card mb-3 " style="max-width: 540px;">
          <div class="row g-0">
            <div class="col-md-4">
              <img src="/Images/@(order.ServiceImageUrl)" class="img-fluid rounded-start" alt="...">
            </div>
            <div class="col-md-8">
              <div class="card-body">
                <h5 class="card-title" id="orderName">@order.ServiceName</h5>
                <p class="card-text" id="orderDescriptio"> @order.Description.</p>
                <p class="card-text"><small class="text-muted"> @order.Date</small></p>
              </div>
            </div>
           </div>
           @if(order.IsConfirmed)
           {
               @if(!order.IsTracking)
               {
                    <button @onclick="TrackOrder" class="btn btn-outline-success" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRight" aria-controls="offcanvasRight">Track Order</button>
               }else
               {

                <div class="d-flex align-items-center">
                    <strong>Connecting to provider..., if she/he does'nt respond in 1 min try again</strong>
                    <div class="spinner-border ms-auto" role="status" aria-hidden="true"></div>
                </div>
               }
           }   


            
        </div>
   
    </dl>
    <!--End Component MarkUp-->

@code {
        private List<Service>? serviceDisplayList;
        public Order? order;
        private HubConnection? hubConnection;
        private PersistingComponentStateSubscription persistingSubscription;
        string? ErrorMsg;
        string? IsAvailableMsg;
        bool IsProviderAvailable;
        bool OpenConnection;
        string? user;



        [Parameter]
        public Order? OrderComponentModel
        {
            get
            {

                return order;
            }

            set
            {
                order = value;
            }
        }


        protected override async Task OnInitializedAsync()
    {

        hubConnection = new HubConnectionBuilder()
        .WithUrl("https://localhost:7168/orderhub")
        .WithAutomaticReconnect()
        .Build();

        hubConnection.Reconnecting += (sender) =>
        {
            this.InvokeAsync(() =>
            {
                var newMessage = "Trying to reconnect...";

            });

            return Task.CompletedTask;
        };

        hubConnection.Reconnected += (sender) =>
        {
            this.InvokeAsync(() =>
        {
                 var newMessage = "Connected to the server";
                 IsAvailableMsg = newMessage;
             });

            return Task.CompletedTask;
        };

        hubConnection.Closed += (sender) =>
        {
            this.InvokeAsync(() =>
            {
                var newMessage = "Connection Closed";
                IsAvailableMsg = newMessage;
                IsProviderAvailable = false;
            });

            return Task.CompletedTask;
        };

        //Client Side / Receiver request    
        hubConnection.On<string, string>("ReceiveAvailableBroadcast", (user, isavailable) =>
        {
            IsAvailableMsg = isavailable;
            InvokeAsync(StateHasChanged);

        });

        await hubConnection.StartAsync();

        //***Component persisting state setup****//
        persistingSubscription =
            ApplicationState.RegisterOnPersisting(PersistOrder);

        if (!ApplicationState.TryTakeFromJson<Order>(
            "fetchdata", out var restored))
        {
            //*The following code get the order from the IOrderEndPoint*//
            //order =
            // await _orderEndpointService.GetOrders();

        }
        else
        {
            order = restored!;
        }

        //Caching the order model
        if (!_cache.TryGetValue("ordercomp", out Order cacheValue))
        {
            cacheValue = order;

            var cacheEntryOptions = new MemoryCacheEntryOptions()
                .SetSlidingExpiration(TimeSpan.FromSeconds(40));

            _cache.Set<Order>("ordercomp", cacheValue, cacheEntryOptions);
        }

        order = cacheValue;

        NavManager.LocationChanged += HandleLocationChanged;

    }



        //Send the Order to signalr request
        //User must be from Identity
        public async Task Send()
        {
            if(hubConnection is not null)
            {
                await hubConnection.SendAsync("SendOrder", user, order);
            }
        }

        //Rediction in blazor
        private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
        {
            Logger.LogInformation("URL of new location: {Location}", e.Location);
        }

        //Disposing the component
        public async ValueTask DisposeAsync()
        {
            if (hubConnection is not null)
            {
                //Dispose the cache
                _cache.Remove("ordercomp");
                _cache.Dispose();
                await hubConnection.DisposeAsync();   
                NavManager.LocationChanged -= HandleLocationChanged;
            }

        }

        //Initiate the order 
        private void TrackOrder()
        {
            if (!_cache.TryGetValue("ordercomp", out Order cacheValue))
            {
                cacheValue = order;

                var cacheEntryOptions = new MemoryCacheEntryOptions()
                    .SetSlidingExpiration(TimeSpan.FromSeconds(40));

                _cache.Set<Order>("ordercomp", cacheValue, cacheEntryOptions);
            }

            order = cacheValue;
            order.IsTracking = true;
            NavManager.NavigateTo("orderdetails", true);
        }

        //Cancelling 
        private async Task CancelOrder()
        {

            order.IsTracking = false;
            await DisposeAsync();
            persistingSubscription.Dispose();
       
        }

        //Completing the order on certain 
        private async Task FinishOrder()
        {

        }

        //Persisting the order  
        private Task PersistOrder()
        {
            ApplicationState.PersistAsJson("fetchdata", _orderEndpointService);

            return Task.CompletedTask;
        }
}
